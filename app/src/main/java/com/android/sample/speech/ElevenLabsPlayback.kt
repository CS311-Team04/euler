package com.android.sample.speech

import android.content.Context
import android.media.MediaPlayer
import java.io.File
import java.io.IOException
import java.security.MessageDigest
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject

/**
 * [SpeechPlayback] implementation that streams audio generated by ElevenLabs.
 *
 * It downloads speech for a message (caching the MP3 in the app cache directory) then plays it
 * through [MediaPlayer]. Only one utterance is played at a time: starting a new playback stops the
 * current one.
 */
open class ElevenLabsPlayback(
    private val context: Context,
    private val apiKeyProvider: () -> String,
    private val voiceIdProvider: () -> String,
    private val modelId: String = "eleven_multilingual_v2",
    private val baseUrl: String = DEFAULT_BASE_URL,
    private val httpClient: OkHttpClient = OkHttpClient(),
    private val coroutineScope: CoroutineScope =
        CoroutineScope(SupervisorJob() + Dispatchers.Main.immediate)
) : SpeechPlayback {

  private val cacheDir: File by lazy {
    File(context.cacheDir, "elevenlabs_audio").apply { if (!exists()) mkdirs() }
  }

  private var mediaPlayer: MediaPlayer? = null
  private var currentJob: Job? = null

  override fun speak(
      text: String,
      utteranceId: String,
      onStart: () -> Unit,
      onDone: () -> Unit,
      onError: (Throwable?) -> Unit
  ) {
    currentJob?.cancel()
    stopInternal()

    currentJob =
        coroutineScope.launch {
          try {
            val audioFile = withContext(Dispatchers.IO) { getOrDownloadAudio(text, utteranceId) }
            startPlayback(audioFile, onStart, onDone, onError)
          } catch (t: Throwable) {
            onError(t)
          }
        }
  }

  override fun stop() {
    currentJob?.cancel()
    currentJob = null
    stopInternal()
  }

  override fun shutdown() {
    stop()
    coroutineScope.cancel()
  }

  protected open suspend fun getOrDownloadAudio(text: String, utteranceId: String): File {
    val voiceId =
        voiceIdProvider().takeIf { it.isNotBlank() }
            ?: throw IllegalStateException(
                "ElevenLabs voice ID is missing. Remplis-le dans ElevenLabsConfig.")
    val apiKey =
        apiKeyProvider().takeIf { it.isNotBlank() }
            ?: throw IllegalStateException(
                "ElevenLabs API key manquante. Ajoute la dans ElevenLabsConfig.")

    val cacheFile = File(cacheDir, cacheFileName(utteranceId, voiceId))
    if (cacheFile.exists()) return cacheFile

    val payload =
        JSONObject()
            .put("text", text)
            .put("model_id", modelId)
            .put("voice_settings", JSONObject().put("stability", 0.3).put("similarity_boost", 0.7))
            .toString()

    val request =
        Request.Builder()
            .url("$baseUrl/text-to-speech/$voiceId")
            .header("xi-api-key", apiKey)
            .header("Accept", "audio/mpeg")
            .post(payload.toRequestBody("application/json".toMediaType()))
            .build()

    val response = httpClient.newCall(request).execute()
    if (!response.isSuccessful) {
      response.close()
      throw IOException("ElevenLabs error: HTTP ${response.code}")
    }

    response.body?.use { body ->
      cacheFile.outputStream().use { output ->
        body.byteStream().use { input -> input.copyTo(output) }
      }
    } ?: throw IOException("ElevenLabs response body empty")

    if (!cacheFile.exists() || cacheFile.length() == 0L) {
      cacheFile.delete()
      throw IOException("ElevenLabs response body empty")
    }

    return cacheFile
  }

  private fun cacheFileName(utteranceId: String, voiceId: String): String {
    val digest = MessageDigest.getInstance("SHA-256")
    val hashBytes = digest.digest("$voiceId|$utteranceId".toByteArray(Charsets.UTF_8))
    val hex = hashBytes.joinToString("") { "%02x".format(it) }
    return "$hex.mp3"
  }

  protected open fun startPlayback(
      audioFile: File,
      onStart: () -> Unit,
      onDone: () -> Unit,
      onError: (Throwable?) -> Unit
  ) {
    val player = MediaPlayer()
    mediaPlayer = player
    try {
      player.setDataSource(audioFile.absolutePath)
      player.setOnPreparedListener {
        it.start()
        onStart()
      }
      player.setOnCompletionListener {
        onDone()
        releasePlayer()
      }
      player.setOnErrorListener { _, what, extra ->
        onError(IOException("MediaPlayer error what=$what extra=$extra"))
        releasePlayer()
        true
      }
      player.prepareAsync()
    } catch (t: Throwable) {
      releasePlayer()
      onError(t)
    }
  }

  protected open fun stopInternal() {
    mediaPlayer?.let {
      it.setOnCompletionListener(null)
      if (it.isPlaying) {
        it.stop()
      }
      releasePlayer()
    }
  }

  private fun releasePlayer() {
    mediaPlayer?.reset()
    mediaPlayer?.release()
    mediaPlayer = null
  }

  companion object {
    private const val DEFAULT_BASE_URL = "https://api.elevenlabs.io/v1"
  }
}
